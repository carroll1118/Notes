# 存储管理方案
### 地址的转换和快表
页号 = 逻辑地址/页长 
页内地址 = 逻辑地址 % 页长
物理地址 = 块号*块长 + 块内地址 + 用户区基址     ==（块内地址  = 页内地址）==

### 页表
（1）多级页表
（2）散列页表
（3）反置页表

页式存储管理中快表放在高速缓存中。

### 页面调度策略
调入策略
置页策略
置换策略

## 页面置换算法
### 最优页面置换算法
(1)功能目标
功能：当缺页中断发生，需要调入新的页面而内存已满时，选择内存当中哪个物理页面被置换。
目标：尽可能减少页面的换入换出次数(即缺页中断的次数)。把未来不再使用的或短期内较少使用的页面换出，通常只能在局部性原理的指导下依据过去的统计数据来进行预测。
页面锁定(frame locking)：用于描述必须常驻内存的操作系统的关键部分或时间关键(time-critical)的应用进程。实现方法是，在页表中添加锁定标志位(lock bit)。

(2)最优页面置换算法
基本思路：当一个缺页中断发生时，对于保存在内存中的每一个逻辑页面，计算在它的下一次访问之前，还需要等待多长时间，从中选择等待时间最长的那个，作为被置换的页面。
不过，这只是一种理想情况，在实际中无法实现，因为操作系统无法知道每一个页面要等待多长时间以后才会被再次访问。
可用作其它算法的性能评价的依据(在一个模拟器上运行某个程序，并记录每一次的页面访问情况，在第二遍运行时即可使用最优算法)。

### 先进先出算法（FIFO）
  	 淘汰最早进入主存的页面。
###  最近最久未使用算法（LRU）
###  最近最不经常使用的算法（LFU）
### 理想页面置换算法
### 时钟页面置换算法
### 第二次机会页面置换算法（FIFO改进算法）
如果是一次写操作，dirty bit会设置为1.说明内存访问这部分数据时是有写入操作的，和硬盘上原数据不一样，所以要写入硬盘，如果是0，对这部分内存没有写操作，那么说明内存和硬盘上内容是一样的，直接丢掉即可。
目的就是减少对硬盘的写操作。
如果used和dirty bit都是0，那么替换掉；如果其中一个是1，那么把这一位设置为0，指针往下走；如果都是1，那先把used换为0，说明有2次机会

#### 缺页中断率
缺页中断率 = 中断次数 / 页面访问总次数

**影响缺页中断的因素：**
（1）分配给程序的内存块数
（2）页面的大小
（3）程序编制方法
（4）页面置换算法

## 段氏存储管理方式

**你知道的越多，你不知道的越多。
有道无术，术尚可求，有术无道，止于术。
如有其它问题，欢迎大家留言，我们一起讨论，一起学习，一起进步**

