@[toc]
# 什么是 Dubbo?
> Apache Dubbo |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 可以和Spring 框架无缝集成。
# Dubbo 的主要应用场景？
* 透明化的远程方法调用，就像调用本地方法一样调用远程方法，只需简单配置，没有任何 API 侵入。
* 软负载均衡及容错机制，可在内网替代 F5 等硬件负载均衡器，降低成本，减少单点。
* 服务自动注册与发现，不再需要写死服务提供方的地址，注册中心基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删除服务提供者。
# Dubbo 的核心功能
* 主要就是如下 3 个核心功能：
### Remoting
* 网络通信框架，提供对多种 NIO 框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。
### Cluster
* 服务框架，提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。
### Registry
* 服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。
# Dubbo 的核心组件
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329145835906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzIyODI3,size_16,color_FFFFFF,t_70)
|节点|	角色说明|
--------|----------
Provider	|暴露服务的服务提供方
Consumer|	调用远程服务的服务消费方
Registry|	服务注册与发现的注册中心
Monitor|	统计服务的调用次数和调用时间的监控中心
Container	|服务运行容器
### Dubbo服务注册与发现的流程？
1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

* Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。
# Dubbo 的负载均衡
> 在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。
## 负载均衡策略
### Random LoadBalance
* **随机**，按权重设置随机概率。
* 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。
### RoundRobin LoadBalance
* **轮询**，按公约后的权重设置轮询比率。
* 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。
### LeastActive LoadBalance
* **最少活跃调用数**，相同活跃数的随机，活跃数指调用前后计数差。
* 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。
### ConsistentHash LoadBalance
* **一致性 Hash**，相同参数的请求总是发到同一提供者。
* 当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。
* 缺省只对第一个参数 Hash，如果要修改，请配置 <dubbo:parameter key="hash.arguments" value="0,1" />
* 缺省用 160 份虚拟节点，如果要修改，请配置 <dubbo:parameter key="hash.nodes" value="320" />

#  Dubbo大厂高频面试题
### Dubbo 有些哪些注册中心？
* Nacos注册中心：Nacos 是 Dubbo 生态系统中重要的注册中心实现。
* Multicast 注册中心： Multicast 注册中心不需要任何中心节点，只要广播地址，就能进行服务注册和发现。基于网络中组播传输实现；
*  Zookeeper 注册中心： 基于分布式协调系统 Zookeeper 实现，采用Zookeeper 的 watch 机制实现数据变更；
*  redis 注册中心： 基于 redis 实现，采用 key/Map 存储，住 key 存储服务名和类型，Map 中 key 存储服务 URL，value 服务过期时间。基于 redis 的发布/订阅模式通知数据变更；
* Simple 注册中心
###  Dubbo 的注册中心集群挂掉，发布者和订阅者之间还能通信么？
* 可以通信的，启动 dubbo 时，消费者会从 注册中心拉取注册的生产者的地址接口等数据，缓存在本地。每次调用时，按照本地存储的地址进行调用；注册中心对等集群，任意一台宕机后，将会切换到另一台；注册中心全部宕机后，服务的提供者和消费者仍能通过本地缓存通讯。服务提供者无状态，任一台宕机后，不影响使用；服务提供者全部宕机，服务消费者会无法使用，并无限次重连等待服务者恢复；
* 挂掉是不要紧的，但前提是你没有增加新的服务，如果你要调用新的服务，则是不能办到的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200329151233230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNzIyODI3,size_16,color_FFFFFF,t_70#pic_center)
### Dubbo 和 Spring Cloud 的关系？
* Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断。而 Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托了 Spirng、Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo定位服务治理,Spirng Cloud 是一个生态。
* Spring Cloud抛弃了Dubbo 的RPC通信，采用的是基于HTTP的REST方式。严格来说，这两种方式各有优劣。虽然在一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适。
* Dubbo的定位始终是一款RPC框架，而Spring Cloud的目的是微服务架构下的一站式解决方案。
### 为什么需要服务治理？
* 过多的服务 URL 配置困难
* 负载均衡分配节点压力过大的情况下也需要部署集群
* 服务依赖混乱，启动顺序不清晰
* 过多服务导致性能指标分析难度较大，需要监控
### dubbo 和 dubbox 之间的区别？
* dubbox 基于 dubbo 上做了一些扩展，如加了服务可 restful 调用，更新了开源组件等。
###  Dubbo 超时时间怎样设置？
* Dubbo 超时时间设置有两种方式：
	* 服务提供者端设置超时时间，在 Dubbo 的用户文档中，推荐如果能在服务
端多配置就尽量多配置，因为服务提供者比消费者更清楚自己提供的服务特
性。
	* 服务消费者端设置超时时间，如果在消费者端设置了超时时间，以消费者端
为主，即优先级更高。因为服务调用方设置超时时间控制性更灵活。如果消
费方超时，服务端线程不会定制，会产生警告。
### Dubbo 支持哪些协议，每种协议的应用场景，优缺点？
* dubbo： 单一长连接和 NIO 异步通讯，适合大并发小数据量的服务调用，以及消费者远大于提供者。传输协议 TCP，异步，Hessian 序列化；
* rmi： 采用 JDK 标准的 rmi 协议实现，传输参数和返回参数对象需要实现Serializable 接口，使用 java 标准序列化机制，使用阻塞式短连接，传输数据包大小混合，消费者和提供者个数差不多，可传文件，传输协议 TCP。多个短连接，TCP 协议传输，同步传输，适用常规的远程服务调用和 rmi 互操作。在依赖低版本的 Common-Collections 包，java 序列化存在安全漏洞；
* webservice： 基于 WebService 的远程调用协议，集成 CXF 实现，提供和原生 WebService 的互操作。多个短连接，基于 HTTP 传输，同步传输，适用系统集成和跨语言调用；
* http： 基于 Http 表单提交的远程调用协议，使用 Spring 的 HttpInvoke 实现。多个短连接，传输协议 HTTP，传入参数大小混合，提供者个数多于消费者，需要给应用程序和浏览器 JS 调用；
* hessian： 集成 Hessian 服务，基于 HTTP 通讯，采用 Servlet 暴露服务，Dubbo 内嵌 Jetty 作为服务器时默认实现，提供与 Hession 服务互操作。多个短连接，同步 HTTP 传输，Hessian 序列化，传入参数较大，提供者大于消费者，提供者压力较大，可传文件；
* memcache： 基于 memcached 实现的 RPC 协议
* redis： 基于 redis 实现的 RPC 协议

**你知道的越多，你不知道的越多。
有道无术，术尚可求，有术无道，止于术。
如有其它问题，欢迎大家留言，我们一起讨论，一起学习，一起进步**
